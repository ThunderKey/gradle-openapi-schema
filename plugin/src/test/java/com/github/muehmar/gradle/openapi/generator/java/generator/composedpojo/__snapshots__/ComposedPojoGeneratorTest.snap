ComposedPojoGenerator[ANY_OF,null]=[
package com.github.muehmar;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.github.muehmar.openapi.util.JacksonNullContainer;
import com.github.muehmar.openapi.util.Tristate;
import java.time.LocalDate;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.validation.Valid;
import javax.validation.constraints.AssertFalse;

/**
 * Composition Description
 */
@JsonDeserialize(builder = ComposedAnyofDto.Builder.class)
public class ComposedAnyofDto {
  private final String username;
  private final LocalDate birthdate;
  private final String requiredStringVal;
  private final String requiredNullableStringVal;
  private final boolean isRequiredNullableStringValPresent;
  private final String optionalStringVal;
  private final String optionalNullableStringVal;
  private final boolean isOptionalNullableStringValNull;
  private final Map<String, Object> additionalProperties;

  public ComposedAnyofDto(
      String username,
      LocalDate birthdate,
      String requiredStringVal,
      String requiredNullableStringVal,
      boolean isRequiredNullableStringValPresent,
      String optionalStringVal,
      String optionalNullableStringVal,
      boolean isOptionalNullableStringValNull,
      Map<String, Object> additionalProperties
    ) {
    this.username = username;
    this.birthdate = birthdate;
    this.requiredStringVal = requiredStringVal;
    this.requiredNullableStringVal = requiredNullableStringVal;
    this.isRequiredNullableStringValPresent = isRequiredNullableStringValPresent;
    this.optionalStringVal = optionalStringVal;
    this.optionalNullableStringVal = optionalNullableStringVal;
    this.isOptionalNullableStringValNull = isOptionalNullableStringValNull;
    this.additionalProperties = Collections.unmodifiableMap(additionalProperties);
  }

  /**
   * Creates an instance of {@link ComposedAnyofDto} from a {@link UserDto}.
   */
  public static ComposedAnyofDto fromUser(UserDto dto) {
    return new ComposedAnyofDto(
      dto.getUsername(),
      dto.getBirthdate(),
      null,
      null,
      false,
      null,
      null,
      false,
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Creates an instance of {@link ComposedAnyofDto} from a {@link
   * NecessityAndNullabilityDto}.
   */
  public static ComposedAnyofDto fromNecessityAndNullability(NecessityAndNullabilityDto dto) {
    return new ComposedAnyofDto(
      null,
      null,
      dto.getRequiredStringVal(),
      dto.getRequiredNullableStringValOr(null),
      true,
      dto.getOptionalStringValOr(null),
      dto.getOptionalNullableStringVal().onValue(val -> val).onNull(() -> null).onAbsent(() -> null),
      dto.getOptionalNullableStringVal().onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false),
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Returns a new instance adding the supplied {@link UserDto}. This will overwrite
   * any shared properties with other schemas to the value of the properties in the
   * supplied {@link UserDto}.
   */
  public ComposedAnyofDto withUser(UserDto dto) {
    return new ComposedAnyofDto(
      dto.getUsername(),
      dto.getBirthdate(),
      requiredStringVal,
      requiredNullableStringVal,
      isRequiredNullableStringValPresent,
      optionalStringVal,
      optionalNullableStringVal,
      isOptionalNullableStringValNull,
      dto.getAdditionalProperties().entrySet().stream()
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (p1, p2) -> p1, () -> new HashMap<>(additionalProperties)))
    );
  }

  /**
   * Returns a new instance adding the supplied {@link NecessityAndNullabilityDto}.
   * This will overwrite any shared properties with other schemas to the value of
   * the properties in the supplied {@link NecessityAndNullabilityDto}.
   */
  public ComposedAnyofDto withNecessityAndNullability(NecessityAndNullabilityDto dto) {
    return new ComposedAnyofDto(
      username,
      birthdate,
      dto.getRequiredStringVal(),
      dto.getRequiredNullableStringValOr(null),
      true,
      dto.getOptionalStringValOr(null),
      dto.getOptionalNullableStringVal().onValue(val -> val).onNull(() -> null).onAbsent(() -> null),
      dto.getOptionalNullableStringVal().onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false),
      dto.getAdditionalProperties().entrySet().stream()
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (p1, p2) -> p1, () -> new HashMap<>(additionalProperties)))
    );
  }

  @JsonProperty("username")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getUsername() {
    return username;
  }

  @JsonProperty("birthdate")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getBirthdate() {
    return birthdate;
  }

  @JsonProperty("requiredStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredStringVal() {
    return requiredStringVal;
  }

  @JsonProperty("requiredNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredNullableStringVal() {
    return isRequiredNullableStringValPresent ? new JacksonNullContainer<>(requiredNullableStringVal) : null;
  }

  @JsonProperty("optionalStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalStringVal() {
    return optionalStringVal;
  }

  @JsonProperty("optionalNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalNullableStringVal() {
    return isOptionalNullableStringValNull ? new JacksonNullContainer<>(optionalNullableStringVal) : optionalNullableStringVal;
  }

  @Valid
  @JsonIgnore
  private List<Object> getAnyOf() {
    if (getValidCount() == 0) {
      return null;
    }
    return fold(dto -> dto, dto -> dto);
  }

  private int getValidCount() {
    return
      (isValidAgainstUserDto() ? 1 : 0) +
      (isValidAgainstNecessityAndNullabilityDto() ? 1 : 0);
  }

  private boolean isValidAgainstUserDto() {
    return
      username != null &&
      birthdate != null;
  }

  private boolean isValidAgainstNecessityAndNullabilityDto() {
    return
      requiredStringVal != null &&
      isRequiredNullableStringValPresent;
  }

  @AssertFalse(message = "Is not valid against one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstNoSchema() {
    return getValidCount() == 0;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      username,
      birthdate,
      requiredStringVal,
      requiredNullableStringVal,
      isRequiredNullableStringValPresent,
      optionalStringVal,
      optionalNullableStringVal,
      isOptionalNullableStringValNull,
      additionalProperties
    );
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || this.getClass() != obj.getClass()) return false;
    final ComposedAnyofDto other = (ComposedAnyofDto) obj;
    return Objects.deepEquals(this.username, other.username)
        && Objects.deepEquals(this.birthdate, other.birthdate)
        && Objects.deepEquals(this.requiredStringVal, other.requiredStringVal)
        && Objects.deepEquals(this.requiredNullableStringVal, other.requiredNullableStringVal)
        && Objects.deepEquals(this.isRequiredNullableStringValPresent, other.isRequiredNullableStringValPresent)
        && Objects.deepEquals(this.optionalStringVal, other.optionalStringVal)
        && Objects.deepEquals(this.optionalNullableStringVal, other.optionalNullableStringVal)
        && Objects.deepEquals(this.isOptionalNullableStringValNull, other.isOptionalNullableStringValNull)
        && Objects.deepEquals(this.additionalProperties, other.additionalProperties);
  }

  @Override
  public String toString() {
    return "ComposedAnyofDto{" +
      "username=" + "'" + username + "'" + ", " +
      "birthdate=" + birthdate + ", " +
      "requiredStringVal=" + "'" + requiredStringVal + "'" + ", " +
      "requiredNullableStringVal=" + "'" + requiredNullableStringVal + "'" + ", " +
      "isRequiredNullableStringValPresent=" + isRequiredNullableStringValPresent + ", " +
      "optionalStringVal=" + "'" + optionalStringVal + "'" + ", " +
      "optionalNullableStringVal=" + "'" + optionalNullableStringVal + "'" + ", " +
      "isOptionalNullableStringValNull=" + isOptionalNullableStringValNull + ", " +
      "additionalProperties=" + additionalProperties +
      "}";
  }

  @JsonPOJOBuilder(withPrefix = "set")
  public static final class Builder {

    private Builder() {
    }

    private String username;
    private LocalDate birthdate;
    private String requiredStringVal;
    private String requiredNullableStringVal;
    private boolean isRequiredNullableStringValPresent = false;
    private String optionalStringVal;
    private String optionalNullableStringVal;
    private boolean isOptionalNullableStringValNull = false;
    private Map<String, Object> additionalProperties = new HashMap<>();

    /**
     * Username
     */
    @JsonProperty("username")
    private Builder setUsername(String username) {
      this.username = username;
      return this;
    }

    /**
     * Birthdate
     */
    @JsonProperty("birthdate")
    private Builder setBirthdate(LocalDate birthdate) {
      this.birthdate = birthdate;
      return this;
    }

    /**
     * RequiredStringVal
     */
    @JsonProperty("requiredStringVal")
    private Builder setRequiredStringVal(String requiredStringVal) {
      this.requiredStringVal = requiredStringVal;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    @JsonProperty("requiredNullableStringVal")
    private Builder setRequiredNullableStringVal(String requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal;
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    private Builder setRequiredNullableStringVal(Optional<String> requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal.orElse(null);
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * OptionalStringVal
     */
    @JsonProperty("optionalStringVal")
    public Builder setOptionalStringVal(String optionalStringVal) {
      this.optionalStringVal = optionalStringVal;
      return this;
    }

    /**
     * OptionalStringVal
     */
    public Builder setOptionalStringVal(Optional<String> optionalStringVal) {
      this.optionalStringVal = optionalStringVal.orElse(null);
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    @JsonProperty("optionalNullableStringVal")
    public Builder setOptionalNullableStringVal(String optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal;
      this.isOptionalNullableStringValNull = optionalNullableStringVal == null;
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    public Builder setOptionalNullableStringVal(Tristate<String> optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal.onValue(val -> val).onNull(() -> null).onAbsent(() -> null);
      this.isOptionalNullableStringValNull = optionalNullableStringVal.onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false);
      return this;
    }

    @JsonAnySetter
    public Builder addAdditionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    public Builder setAdditionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties = new HashMap<>(additionalProperties);
      return this;
    }

    public ComposedAnyofDto build() {
      return new ComposedAnyofDto(username, birthdate, requiredStringVal, requiredNullableStringVal, isRequiredNullableStringValPresent, optionalStringVal, optionalNullableStringVal, isOptionalNullableStringValNull, additionalProperties);
    }
  }
}
]


ComposedPojoGenerator[ONE_OF,Discriminator(propertyName->requiredStringVal, mapping->Optional({UserValue->User, NNVariantsValue->NecessityAndNullability}))]=[
package com.github.muehmar;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.github.muehmar.openapi.util.JacksonNullContainer;
import com.github.muehmar.openapi.util.Tristate;
import java.time.LocalDate;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.validation.Valid;
import javax.validation.constraints.AssertFalse;
import javax.validation.constraints.AssertTrue;

/**
 * Composition Description
 */
@JsonDeserialize(builder = ComposedOneofDto.Builder.class)
public class ComposedOneofDto {
  private final String username;
  private final LocalDate birthdate;
  private final String requiredStringVal;
  private final String requiredNullableStringVal;
  private final boolean isRequiredNullableStringValPresent;
  private final String optionalStringVal;
  private final String optionalNullableStringVal;
  private final boolean isOptionalNullableStringValNull;
  private final Map<String, Object> additionalProperties;

  public ComposedOneofDto(
      String username,
      LocalDate birthdate,
      String requiredStringVal,
      String requiredNullableStringVal,
      boolean isRequiredNullableStringValPresent,
      String optionalStringVal,
      String optionalNullableStringVal,
      boolean isOptionalNullableStringValNull,
      Map<String, Object> additionalProperties
    ) {
    this.username = username;
    this.birthdate = birthdate;
    this.requiredStringVal = requiredStringVal;
    this.requiredNullableStringVal = requiredNullableStringVal;
    this.isRequiredNullableStringValPresent = isRequiredNullableStringValPresent;
    this.optionalStringVal = optionalStringVal;
    this.optionalNullableStringVal = optionalNullableStringVal;
    this.isOptionalNullableStringValNull = isOptionalNullableStringValNull;
    this.additionalProperties = Collections.unmodifiableMap(additionalProperties);
  }

  /**
   * Creates an instance of {@link ComposedOneofDto} from a {@link UserDto}.
   */
  public static ComposedOneofDto fromUser(UserDto dto) {
    return new ComposedOneofDto(
      dto.getUsername(),
      dto.getBirthdate(),
      "UserValue",
      null,
      false,
      null,
      null,
      false,
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Creates an instance of {@link ComposedOneofDto} from a {@link
   * NecessityAndNullabilityDto}.
   */
  public static ComposedOneofDto fromNecessityAndNullability(NecessityAndNullabilityDto dto) {
    return new ComposedOneofDto(
      null,
      null,
      "NNVariantsValue",
      dto.getRequiredNullableStringValOr(null),
      true,
      dto.getOptionalStringValOr(null),
      dto.getOptionalNullableStringVal().onValue(val -> val).onNull(() -> null).onAbsent(() -> null),
      dto.getOptionalNullableStringVal().onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false),
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  @JsonProperty("username")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getUsername() {
    return username;
  }

  @JsonProperty("birthdate")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getBirthdate() {
    return birthdate;
  }

  @JsonProperty("requiredStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredStringVal() {
    return requiredStringVal;
  }

  @JsonProperty("requiredNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredNullableStringVal() {
    return isRequiredNullableStringValPresent ? new JacksonNullContainer<>(requiredNullableStringVal) : null;
  }

  @JsonProperty("optionalStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalStringVal() {
    return optionalStringVal;
  }

  @JsonProperty("optionalNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalNullableStringVal() {
    return isOptionalNullableStringValNull ? new JacksonNullContainer<>(optionalNullableStringVal) : optionalNullableStringVal;
  }

  @Valid
  @JsonIgnore
  private Object getOneOf() {
    if (getValidCount() != 1) {
      return null;
    }
    return fold(dto -> dto, dto -> dto, () -> null);
  }

  private int getValidCount() {
    return
      (isValidAgainstUserDto() ? 1 : 0) +
      (isValidAgainstNecessityAndNullabilityDto() ? 1 : 0);
  }

  private boolean isValidAgainstUserDto() {
    return
      username != null &&
      birthdate != null;
  }

  private boolean isValidAgainstNecessityAndNullabilityDto() {
    return
      requiredStringVal != null &&
      isRequiredNullableStringValPresent;
  }

  @AssertTrue(message = "Not valid against the schema described by the discriminator")
  @JsonIgnore
  private boolean isValidAgainstTheCorrectSchema() {
    if (requiredStringVal == null) {
      return false;
    }
    switch(requiredStringVal) {
      case "UserValue": return isValidAgainstUserDto();
      case "NNVariantsValue": return isValidAgainstNecessityAndNullabilityDto();
    }
    return false;
  }

  @AssertFalse(message = "Is not valid against one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstNoSchema() {
    return getValidCount() == 0;
  }

  @AssertFalse(message = "Is valid against more than one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstMoreThanOneSchema() {
    return getValidCount() > 1;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      username,
      birthdate,
      requiredStringVal,
      requiredNullableStringVal,
      isRequiredNullableStringValPresent,
      optionalStringVal,
      optionalNullableStringVal,
      isOptionalNullableStringValNull,
      additionalProperties
    );
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || this.getClass() != obj.getClass()) return false;
    final ComposedOneofDto other = (ComposedOneofDto) obj;
    return Objects.deepEquals(this.username, other.username)
        && Objects.deepEquals(this.birthdate, other.birthdate)
        && Objects.deepEquals(this.requiredStringVal, other.requiredStringVal)
        && Objects.deepEquals(this.requiredNullableStringVal, other.requiredNullableStringVal)
        && Objects.deepEquals(this.isRequiredNullableStringValPresent, other.isRequiredNullableStringValPresent)
        && Objects.deepEquals(this.optionalStringVal, other.optionalStringVal)
        && Objects.deepEquals(this.optionalNullableStringVal, other.optionalNullableStringVal)
        && Objects.deepEquals(this.isOptionalNullableStringValNull, other.isOptionalNullableStringValNull)
        && Objects.deepEquals(this.additionalProperties, other.additionalProperties);
  }

  @Override
  public String toString() {
    return "ComposedOneofDto{" +
      "username=" + "'" + username + "'" + ", " +
      "birthdate=" + birthdate + ", " +
      "requiredStringVal=" + "'" + requiredStringVal + "'" + ", " +
      "requiredNullableStringVal=" + "'" + requiredNullableStringVal + "'" + ", " +
      "isRequiredNullableStringValPresent=" + isRequiredNullableStringValPresent + ", " +
      "optionalStringVal=" + "'" + optionalStringVal + "'" + ", " +
      "optionalNullableStringVal=" + "'" + optionalNullableStringVal + "'" + ", " +
      "isOptionalNullableStringValNull=" + isOptionalNullableStringValNull + ", " +
      "additionalProperties=" + additionalProperties +
      "}";
  }

  @JsonPOJOBuilder(withPrefix = "set")
  public static final class Builder {

    private Builder() {
    }

    private String username;
    private LocalDate birthdate;
    private String requiredStringVal;
    private String requiredNullableStringVal;
    private boolean isRequiredNullableStringValPresent = false;
    private String optionalStringVal;
    private String optionalNullableStringVal;
    private boolean isOptionalNullableStringValNull = false;
    private Map<String, Object> additionalProperties = new HashMap<>();

    /**
     * Username
     */
    @JsonProperty("username")
    private Builder setUsername(String username) {
      this.username = username;
      return this;
    }

    /**
     * Birthdate
     */
    @JsonProperty("birthdate")
    private Builder setBirthdate(LocalDate birthdate) {
      this.birthdate = birthdate;
      return this;
    }

    /**
     * RequiredStringVal
     */
    @JsonProperty("requiredStringVal")
    private Builder setRequiredStringVal(String requiredStringVal) {
      this.requiredStringVal = requiredStringVal;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    @JsonProperty("requiredNullableStringVal")
    private Builder setRequiredNullableStringVal(String requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal;
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    private Builder setRequiredNullableStringVal(Optional<String> requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal.orElse(null);
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * OptionalStringVal
     */
    @JsonProperty("optionalStringVal")
    public Builder setOptionalStringVal(String optionalStringVal) {
      this.optionalStringVal = optionalStringVal;
      return this;
    }

    /**
     * OptionalStringVal
     */
    public Builder setOptionalStringVal(Optional<String> optionalStringVal) {
      this.optionalStringVal = optionalStringVal.orElse(null);
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    @JsonProperty("optionalNullableStringVal")
    public Builder setOptionalNullableStringVal(String optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal;
      this.isOptionalNullableStringValNull = optionalNullableStringVal == null;
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    public Builder setOptionalNullableStringVal(Tristate<String> optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal.onValue(val -> val).onNull(() -> null).onAbsent(() -> null);
      this.isOptionalNullableStringValNull = optionalNullableStringVal.onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false);
      return this;
    }

    @JsonAnySetter
    public Builder addAdditionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    public Builder setAdditionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties = new HashMap<>(additionalProperties);
      return this;
    }

    public ComposedOneofDto build() {
      return new ComposedOneofDto(username, birthdate, requiredStringVal, requiredNullableStringVal, isRequiredNullableStringValPresent, optionalStringVal, optionalNullableStringVal, isOptionalNullableStringValNull, additionalProperties);
    }
  }
}
]


ComposedPojoGenerator[ONE_OF,Discriminator(propertyName->requiredStringVal, mapping->Optional.empty)]=[
package com.github.muehmar;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.github.muehmar.openapi.util.JacksonNullContainer;
import com.github.muehmar.openapi.util.Tristate;
import java.time.LocalDate;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.validation.Valid;
import javax.validation.constraints.AssertFalse;
import javax.validation.constraints.AssertTrue;

/**
 * Composition Description
 */
@JsonDeserialize(builder = ComposedOneofDto.Builder.class)
public class ComposedOneofDto {
  private final String username;
  private final LocalDate birthdate;
  private final String requiredStringVal;
  private final String requiredNullableStringVal;
  private final boolean isRequiredNullableStringValPresent;
  private final String optionalStringVal;
  private final String optionalNullableStringVal;
  private final boolean isOptionalNullableStringValNull;
  private final Map<String, Object> additionalProperties;

  public ComposedOneofDto(
      String username,
      LocalDate birthdate,
      String requiredStringVal,
      String requiredNullableStringVal,
      boolean isRequiredNullableStringValPresent,
      String optionalStringVal,
      String optionalNullableStringVal,
      boolean isOptionalNullableStringValNull,
      Map<String, Object> additionalProperties
    ) {
    this.username = username;
    this.birthdate = birthdate;
    this.requiredStringVal = requiredStringVal;
    this.requiredNullableStringVal = requiredNullableStringVal;
    this.isRequiredNullableStringValPresent = isRequiredNullableStringValPresent;
    this.optionalStringVal = optionalStringVal;
    this.optionalNullableStringVal = optionalNullableStringVal;
    this.isOptionalNullableStringValNull = isOptionalNullableStringValNull;
    this.additionalProperties = Collections.unmodifiableMap(additionalProperties);
  }

  /**
   * Creates an instance of {@link ComposedOneofDto} from a {@link UserDto}.
   */
  public static ComposedOneofDto fromUser(UserDto dto) {
    return new ComposedOneofDto(
      dto.getUsername(),
      dto.getBirthdate(),
      "User",
      null,
      false,
      null,
      null,
      false,
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Creates an instance of {@link ComposedOneofDto} from a {@link
   * NecessityAndNullabilityDto}.
   */
  public static ComposedOneofDto fromNecessityAndNullability(NecessityAndNullabilityDto dto) {
    return new ComposedOneofDto(
      null,
      null,
      "NecessityAndNullability",
      dto.getRequiredNullableStringValOr(null),
      true,
      dto.getOptionalStringValOr(null),
      dto.getOptionalNullableStringVal().onValue(val -> val).onNull(() -> null).onAbsent(() -> null),
      dto.getOptionalNullableStringVal().onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false),
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  @JsonProperty("username")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getUsername() {
    return username;
  }

  @JsonProperty("birthdate")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getBirthdate() {
    return birthdate;
  }

  @JsonProperty("requiredStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredStringVal() {
    return requiredStringVal;
  }

  @JsonProperty("requiredNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredNullableStringVal() {
    return isRequiredNullableStringValPresent ? new JacksonNullContainer<>(requiredNullableStringVal) : null;
  }

  @JsonProperty("optionalStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalStringVal() {
    return optionalStringVal;
  }

  @JsonProperty("optionalNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalNullableStringVal() {
    return isOptionalNullableStringValNull ? new JacksonNullContainer<>(optionalNullableStringVal) : optionalNullableStringVal;
  }

  @Valid
  @JsonIgnore
  private Object getOneOf() {
    if (getValidCount() != 1) {
      return null;
    }
    return fold(dto -> dto, dto -> dto, () -> null);
  }

  private int getValidCount() {
    return
      (isValidAgainstUserDto() ? 1 : 0) +
      (isValidAgainstNecessityAndNullabilityDto() ? 1 : 0);
  }

  private boolean isValidAgainstUserDto() {
    return
      username != null &&
      birthdate != null;
  }

  private boolean isValidAgainstNecessityAndNullabilityDto() {
    return
      requiredStringVal != null &&
      isRequiredNullableStringValPresent;
  }

  @AssertTrue(message = "Not valid against the schema described by the discriminator")
  @JsonIgnore
  private boolean isValidAgainstTheCorrectSchema() {
    if (requiredStringVal == null) {
      return false;
    }
    switch(requiredStringVal) {
      case "User": return isValidAgainstUserDto();
      case "NecessityAndNullability": return isValidAgainstNecessityAndNullabilityDto();
    }
    return false;
  }

  @AssertFalse(message = "Is not valid against one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstNoSchema() {
    return getValidCount() == 0;
  }

  @AssertFalse(message = "Is valid against more than one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstMoreThanOneSchema() {
    return getValidCount() > 1;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      username,
      birthdate,
      requiredStringVal,
      requiredNullableStringVal,
      isRequiredNullableStringValPresent,
      optionalStringVal,
      optionalNullableStringVal,
      isOptionalNullableStringValNull,
      additionalProperties
    );
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || this.getClass() != obj.getClass()) return false;
    final ComposedOneofDto other = (ComposedOneofDto) obj;
    return Objects.deepEquals(this.username, other.username)
        && Objects.deepEquals(this.birthdate, other.birthdate)
        && Objects.deepEquals(this.requiredStringVal, other.requiredStringVal)
        && Objects.deepEquals(this.requiredNullableStringVal, other.requiredNullableStringVal)
        && Objects.deepEquals(this.isRequiredNullableStringValPresent, other.isRequiredNullableStringValPresent)
        && Objects.deepEquals(this.optionalStringVal, other.optionalStringVal)
        && Objects.deepEquals(this.optionalNullableStringVal, other.optionalNullableStringVal)
        && Objects.deepEquals(this.isOptionalNullableStringValNull, other.isOptionalNullableStringValNull)
        && Objects.deepEquals(this.additionalProperties, other.additionalProperties);
  }

  @Override
  public String toString() {
    return "ComposedOneofDto{" +
      "username=" + "'" + username + "'" + ", " +
      "birthdate=" + birthdate + ", " +
      "requiredStringVal=" + "'" + requiredStringVal + "'" + ", " +
      "requiredNullableStringVal=" + "'" + requiredNullableStringVal + "'" + ", " +
      "isRequiredNullableStringValPresent=" + isRequiredNullableStringValPresent + ", " +
      "optionalStringVal=" + "'" + optionalStringVal + "'" + ", " +
      "optionalNullableStringVal=" + "'" + optionalNullableStringVal + "'" + ", " +
      "isOptionalNullableStringValNull=" + isOptionalNullableStringValNull + ", " +
      "additionalProperties=" + additionalProperties +
      "}";
  }

  @JsonPOJOBuilder(withPrefix = "set")
  public static final class Builder {

    private Builder() {
    }

    private String username;
    private LocalDate birthdate;
    private String requiredStringVal;
    private String requiredNullableStringVal;
    private boolean isRequiredNullableStringValPresent = false;
    private String optionalStringVal;
    private String optionalNullableStringVal;
    private boolean isOptionalNullableStringValNull = false;
    private Map<String, Object> additionalProperties = new HashMap<>();

    /**
     * Username
     */
    @JsonProperty("username")
    private Builder setUsername(String username) {
      this.username = username;
      return this;
    }

    /**
     * Birthdate
     */
    @JsonProperty("birthdate")
    private Builder setBirthdate(LocalDate birthdate) {
      this.birthdate = birthdate;
      return this;
    }

    /**
     * RequiredStringVal
     */
    @JsonProperty("requiredStringVal")
    private Builder setRequiredStringVal(String requiredStringVal) {
      this.requiredStringVal = requiredStringVal;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    @JsonProperty("requiredNullableStringVal")
    private Builder setRequiredNullableStringVal(String requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal;
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    private Builder setRequiredNullableStringVal(Optional<String> requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal.orElse(null);
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * OptionalStringVal
     */
    @JsonProperty("optionalStringVal")
    public Builder setOptionalStringVal(String optionalStringVal) {
      this.optionalStringVal = optionalStringVal;
      return this;
    }

    /**
     * OptionalStringVal
     */
    public Builder setOptionalStringVal(Optional<String> optionalStringVal) {
      this.optionalStringVal = optionalStringVal.orElse(null);
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    @JsonProperty("optionalNullableStringVal")
    public Builder setOptionalNullableStringVal(String optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal;
      this.isOptionalNullableStringValNull = optionalNullableStringVal == null;
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    public Builder setOptionalNullableStringVal(Tristate<String> optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal.onValue(val -> val).onNull(() -> null).onAbsent(() -> null);
      this.isOptionalNullableStringValNull = optionalNullableStringVal.onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false);
      return this;
    }

    @JsonAnySetter
    public Builder addAdditionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    public Builder setAdditionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties = new HashMap<>(additionalProperties);
      return this;
    }

    public ComposedOneofDto build() {
      return new ComposedOneofDto(username, birthdate, requiredStringVal, requiredNullableStringVal, isRequiredNullableStringValPresent, optionalStringVal, optionalNullableStringVal, isOptionalNullableStringValNull, additionalProperties);
    }
  }
}
]


ComposedPojoGenerator[ONE_OF,null]=[
package com.github.muehmar;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.github.muehmar.openapi.util.JacksonNullContainer;
import com.github.muehmar.openapi.util.Tristate;
import java.time.LocalDate;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.validation.Valid;
import javax.validation.constraints.AssertFalse;

/**
 * Composition Description
 */
@JsonDeserialize(builder = ComposedOneofDto.Builder.class)
public class ComposedOneofDto {
  private final String username;
  private final LocalDate birthdate;
  private final String requiredStringVal;
  private final String requiredNullableStringVal;
  private final boolean isRequiredNullableStringValPresent;
  private final String optionalStringVal;
  private final String optionalNullableStringVal;
  private final boolean isOptionalNullableStringValNull;
  private final Map<String, Object> additionalProperties;

  public ComposedOneofDto(
      String username,
      LocalDate birthdate,
      String requiredStringVal,
      String requiredNullableStringVal,
      boolean isRequiredNullableStringValPresent,
      String optionalStringVal,
      String optionalNullableStringVal,
      boolean isOptionalNullableStringValNull,
      Map<String, Object> additionalProperties
    ) {
    this.username = username;
    this.birthdate = birthdate;
    this.requiredStringVal = requiredStringVal;
    this.requiredNullableStringVal = requiredNullableStringVal;
    this.isRequiredNullableStringValPresent = isRequiredNullableStringValPresent;
    this.optionalStringVal = optionalStringVal;
    this.optionalNullableStringVal = optionalNullableStringVal;
    this.isOptionalNullableStringValNull = isOptionalNullableStringValNull;
    this.additionalProperties = Collections.unmodifiableMap(additionalProperties);
  }

  /**
   * Creates an instance of {@link ComposedOneofDto} from a {@link UserDto}.
   */
  public static ComposedOneofDto fromUser(UserDto dto) {
    return new ComposedOneofDto(
      dto.getUsername(),
      dto.getBirthdate(),
      null,
      null,
      false,
      null,
      null,
      false,
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Creates an instance of {@link ComposedOneofDto} from a {@link
   * NecessityAndNullabilityDto}.
   */
  public static ComposedOneofDto fromNecessityAndNullability(NecessityAndNullabilityDto dto) {
    return new ComposedOneofDto(
      null,
      null,
      dto.getRequiredStringVal(),
      dto.getRequiredNullableStringValOr(null),
      true,
      dto.getOptionalStringValOr(null),
      dto.getOptionalNullableStringVal().onValue(val -> val).onNull(() -> null).onAbsent(() -> null),
      dto.getOptionalNullableStringVal().onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false),
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  @JsonProperty("username")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getUsername() {
    return username;
  }

  @JsonProperty("birthdate")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getBirthdate() {
    return birthdate;
  }

  @JsonProperty("requiredStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredStringVal() {
    return requiredStringVal;
  }

  @JsonProperty("requiredNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getRequiredNullableStringVal() {
    return isRequiredNullableStringValPresent ? new JacksonNullContainer<>(requiredNullableStringVal) : null;
  }

  @JsonProperty("optionalStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalStringVal() {
    return optionalStringVal;
  }

  @JsonProperty("optionalNullableStringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getOptionalNullableStringVal() {
    return isOptionalNullableStringValNull ? new JacksonNullContainer<>(optionalNullableStringVal) : optionalNullableStringVal;
  }

  @Valid
  @JsonIgnore
  private Object getOneOf() {
    if (getValidCount() != 1) {
      return null;
    }
    return fold(dto -> dto, dto -> dto, () -> null);
  }

  private int getValidCount() {
    return
      (isValidAgainstUserDto() ? 1 : 0) +
      (isValidAgainstNecessityAndNullabilityDto() ? 1 : 0);
  }

  private boolean isValidAgainstUserDto() {
    return
      username != null &&
      birthdate != null;
  }

  private boolean isValidAgainstNecessityAndNullabilityDto() {
    return
      requiredStringVal != null &&
      isRequiredNullableStringValPresent;
  }

  @AssertFalse(message = "Is not valid against one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstNoSchema() {
    return getValidCount() == 0;
  }

  @AssertFalse(message = "Is valid against more than one of the schemas [User, NecessityAndNullability]")
  @JsonIgnore
  private boolean isValidAgainstMoreThanOneSchema() {
    return getValidCount() > 1;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      username,
      birthdate,
      requiredStringVal,
      requiredNullableStringVal,
      isRequiredNullableStringValPresent,
      optionalStringVal,
      optionalNullableStringVal,
      isOptionalNullableStringValNull,
      additionalProperties
    );
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || this.getClass() != obj.getClass()) return false;
    final ComposedOneofDto other = (ComposedOneofDto) obj;
    return Objects.deepEquals(this.username, other.username)
        && Objects.deepEquals(this.birthdate, other.birthdate)
        && Objects.deepEquals(this.requiredStringVal, other.requiredStringVal)
        && Objects.deepEquals(this.requiredNullableStringVal, other.requiredNullableStringVal)
        && Objects.deepEquals(this.isRequiredNullableStringValPresent, other.isRequiredNullableStringValPresent)
        && Objects.deepEquals(this.optionalStringVal, other.optionalStringVal)
        && Objects.deepEquals(this.optionalNullableStringVal, other.optionalNullableStringVal)
        && Objects.deepEquals(this.isOptionalNullableStringValNull, other.isOptionalNullableStringValNull)
        && Objects.deepEquals(this.additionalProperties, other.additionalProperties);
  }

  @Override
  public String toString() {
    return "ComposedOneofDto{" +
      "username=" + "'" + username + "'" + ", " +
      "birthdate=" + birthdate + ", " +
      "requiredStringVal=" + "'" + requiredStringVal + "'" + ", " +
      "requiredNullableStringVal=" + "'" + requiredNullableStringVal + "'" + ", " +
      "isRequiredNullableStringValPresent=" + isRequiredNullableStringValPresent + ", " +
      "optionalStringVal=" + "'" + optionalStringVal + "'" + ", " +
      "optionalNullableStringVal=" + "'" + optionalNullableStringVal + "'" + ", " +
      "isOptionalNullableStringValNull=" + isOptionalNullableStringValNull + ", " +
      "additionalProperties=" + additionalProperties +
      "}";
  }

  @JsonPOJOBuilder(withPrefix = "set")
  public static final class Builder {

    private Builder() {
    }

    private String username;
    private LocalDate birthdate;
    private String requiredStringVal;
    private String requiredNullableStringVal;
    private boolean isRequiredNullableStringValPresent = false;
    private String optionalStringVal;
    private String optionalNullableStringVal;
    private boolean isOptionalNullableStringValNull = false;
    private Map<String, Object> additionalProperties = new HashMap<>();

    /**
     * Username
     */
    @JsonProperty("username")
    private Builder setUsername(String username) {
      this.username = username;
      return this;
    }

    /**
     * Birthdate
     */
    @JsonProperty("birthdate")
    private Builder setBirthdate(LocalDate birthdate) {
      this.birthdate = birthdate;
      return this;
    }

    /**
     * RequiredStringVal
     */
    @JsonProperty("requiredStringVal")
    private Builder setRequiredStringVal(String requiredStringVal) {
      this.requiredStringVal = requiredStringVal;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    @JsonProperty("requiredNullableStringVal")
    private Builder setRequiredNullableStringVal(String requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal;
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * RequiredNullableStringVal
     */
    private Builder setRequiredNullableStringVal(Optional<String> requiredNullableStringVal) {
      this.requiredNullableStringVal = requiredNullableStringVal.orElse(null);
      this.isRequiredNullableStringValPresent = true;
      return this;
    }

    /**
     * OptionalStringVal
     */
    @JsonProperty("optionalStringVal")
    public Builder setOptionalStringVal(String optionalStringVal) {
      this.optionalStringVal = optionalStringVal;
      return this;
    }

    /**
     * OptionalStringVal
     */
    public Builder setOptionalStringVal(Optional<String> optionalStringVal) {
      this.optionalStringVal = optionalStringVal.orElse(null);
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    @JsonProperty("optionalNullableStringVal")
    public Builder setOptionalNullableStringVal(String optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal;
      this.isOptionalNullableStringValNull = optionalNullableStringVal == null;
      return this;
    }

    /**
     * OptionalNullableStringVal
     */
    public Builder setOptionalNullableStringVal(Tristate<String> optionalNullableStringVal) {
      this.optionalNullableStringVal = optionalNullableStringVal.onValue(val -> val).onNull(() -> null).onAbsent(() -> null);
      this.isOptionalNullableStringValNull = optionalNullableStringVal.onValue(ignore -> false).onNull(() -> true).onAbsent(() -> false);
      return this;
    }

    @JsonAnySetter
    public Builder addAdditionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    public Builder setAdditionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties = new HashMap<>(additionalProperties);
      return this;
    }

    public ComposedOneofDto build() {
      return new ComposedOneofDto(username, birthdate, requiredStringVal, requiredNullableStringVal, isRequiredNullableStringValPresent, optionalStringVal, optionalNullableStringVal, isOptionalNullableStringValNull, additionalProperties);
    }
  }
}
]


composedPojoWithEnumInSubPojos=[
package com.github.muehmar;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.validation.Valid;
import javax.validation.constraints.AssertFalse;

@JsonDeserialize(builder = ComposedPojoDto.Builder.class)
public class ComposedPojoDto {
  private final String stringVal;
  private final ObjectPojo1Dto.Color color;
  private final Integer intVal;
  private final Map<String, Object> additionalProperties;

  public ComposedPojoDto(
      String stringVal,
      ObjectPojo1Dto.Color color,
      Integer intVal,
      Map<String, Object> additionalProperties
    ) {
    this.stringVal = stringVal;
    this.color = color;
    this.intVal = intVal;
    this.additionalProperties = Collections.unmodifiableMap(additionalProperties);
  }

  /**
   * Creates an instance of {@link ComposedPojoDto} from a {@link ObjectPojo1Dto}.
   */
  public static ComposedPojoDto fromObjectPojo1(ObjectPojo1Dto dto) {
    return new ComposedPojoDto(
      dto.getStringVal(),
      null,
      null,
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Creates an instance of {@link ComposedPojoDto} from a {@link ObjectPojo1Dto}.
   */
  public static ComposedPojoDto fromObjectPojo1(ObjectPojo1Dto dto) {
    return new ComposedPojoDto(
      null,
      dto.getColor(),
      dto.getIntVal(),
      dto.getAdditionalProperties().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );
  }

  /**
   * Returns a new instance adding the supplied {@link ObjectPojo1Dto}. This will
   * overwrite any shared properties with other schemas to the value of the
   * properties in the supplied {@link ObjectPojo1Dto}.
   */
  public ComposedPojoDto withObjectPojo1(ObjectPojo1Dto dto) {
    return new ComposedPojoDto(
      dto.getStringVal(),
      color,
      intVal,
      dto.getAdditionalProperties().entrySet().stream()
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (p1, p2) -> p1, () -> new HashMap<>(additionalProperties)))
    );
  }

  /**
   * Returns a new instance adding the supplied {@link ObjectPojo1Dto}. This will
   * overwrite any shared properties with other schemas to the value of the
   * properties in the supplied {@link ObjectPojo1Dto}.
   */
  public ComposedPojoDto withObjectPojo1(ObjectPojo1Dto dto) {
    return new ComposedPojoDto(
      stringVal,
      dto.getColor(),
      dto.getIntVal(),
      dto.getAdditionalProperties().entrySet().stream()
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (p1, p2) -> p1, () -> new HashMap<>(additionalProperties)))
    );
  }

  @JsonProperty("stringVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getStringVal() {
    return stringVal;
  }

  @JsonProperty("color")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getColor() {
    return color;
  }

  @JsonProperty("intVal")
  @JsonInclude(JsonInclude.Include.NON_NULL)
  private Object getIntVal() {
    return intVal;
  }

  @Valid
  @JsonIgnore
  private List<Object> getAnyOf() {
    if (getValidCount() == 0) {
      return null;
    }
    return fold(dto -> dto, dto -> dto);
  }

  private int getValidCount() {
    return
      (isValidAgainstObjectPojo1Dto() ? 1 : 0) +
      (isValidAgainstObjectPojo1Dto() ? 1 : 0);
  }

  private boolean isValidAgainstObjectPojo1Dto() {
    return
      stringVal != null;
  }

  private boolean isValidAgainstObjectPojo1Dto() {
    return
      color != null &&
      intVal != null;
  }

  @AssertFalse(message = "Is not valid against one of the schemas [ObjectPojo1, ObjectPojo1]")
  @JsonIgnore
  private boolean isValidAgainstNoSchema() {
    return getValidCount() == 0;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      stringVal,
      color,
      intVal,
      additionalProperties
    );
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || this.getClass() != obj.getClass()) return false;
    final ComposedPojoDto other = (ComposedPojoDto) obj;
    return Objects.deepEquals(this.stringVal, other.stringVal)
        && Objects.deepEquals(this.color, other.color)
        && Objects.deepEquals(this.intVal, other.intVal)
        && Objects.deepEquals(this.additionalProperties, other.additionalProperties);
  }

  @Override
  public String toString() {
    return "ComposedPojoDto{" +
      "stringVal=" + "'" + stringVal + "'" + ", " +
      "color=" + color + ", " +
      "intVal=" + intVal + ", " +
      "additionalProperties=" + additionalProperties +
      "}";
  }

  @JsonPOJOBuilder(withPrefix = "set")
  public static final class Builder {

    private Builder() {
    }

    private String stringVal;
    private ObjectPojo1Dto.Color color;
    private Integer intVal;
    private Map<String, Object> additionalProperties = new HashMap<>();

    /**
     * stringVal
     */
    @JsonProperty("stringVal")
    private Builder setStringVal(String stringVal) {
      this.stringVal = stringVal;
      return this;
    }

    /**
     * Color
     */
    @JsonProperty("color")
    private Builder setColor(ObjectPojo1Dto.Color color) {
      this.color = color;
      return this;
    }

    /**
     * intVal
     */
    @JsonProperty("intVal")
    private Builder setIntVal(Integer intVal) {
      this.intVal = intVal;
      return this;
    }

    @JsonAnySetter
    public Builder addAdditionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    public Builder setAdditionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties = new HashMap<>(additionalProperties);
      return this;
    }

    public ComposedPojoDto build() {
      return new ComposedPojoDto(stringVal, color, intVal, additionalProperties);
    }
  }
}
]