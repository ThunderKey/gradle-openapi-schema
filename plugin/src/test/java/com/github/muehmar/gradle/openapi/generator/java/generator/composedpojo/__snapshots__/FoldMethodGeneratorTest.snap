AnyOf=[

public <T> List<T> fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  final List<T> result = new ArrayList<>();
  if (isValidAgainstUser()) {
    result.add(onUserDto.apply(asUserDto()));
  }
  if (isValidAgainstNecessityAndNullability()) {
    result.add(onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto()));
  }
  return result;
}
]


OneOfDiscriminatorWithMapping=[
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if ("UserValue".equals(requiredStringVal) && isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if ("NNVariantsValue".equals(requiredStringVal) && isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]


OneOfDiscriminatorWithoutMapping=[
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if ("User".equals(requiredStringVal) && isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if ("NecessityAndNullability".equals(requiredStringVal) && isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]


OneOfNoDiscriminator=[
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if (isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if (isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]