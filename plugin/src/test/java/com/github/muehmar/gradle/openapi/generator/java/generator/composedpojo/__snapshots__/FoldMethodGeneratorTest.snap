AnyOf=[

/**
 * Folds this instance using the given mapping functions for the DTO's. All
 * mapping functions gets executed with its corresponding DTO as input if this
 * instance is valid against the corresponding schema and the results are returned
 * in a list. The order of the elements in the returned list is deterministic: The
 * order corresponds to the order of the mapping function arguments, i.e. the
 * result of the first mapping function will always be at the first position in
 * the list (if the function gets executed).<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against at least one of the schemas. If it is
 * valid against no schema, it will simply return an empty list.
 */
public <T> List<T> fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  final List<T> result = new ArrayList<>();
  if (isValidAgainstUser()) {
    result.add(onUserDto.apply(asUserDto()));
  }
  if (isValidAgainstNecessityAndNullability()) {
    result.add(onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto()));
  }
  return result;
}
]


OneOfDiscriminatorWithMapping=[
/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * Unlike {@link ComposedOneofDto#fold(Function, Function)}, this method accepts
 * as last parameter a {@link Supplier} which gets called in case this instance is
 * not valid against exactly one of the defined schemas and its value is returned.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if ("UserValue".equals(requiredStringVal) && isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if ("NNVariantsValue".equals(requiredStringVal) && isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against exactly one of the schemas. If it is
 * either valid against no schema or multiple schemas, it will throw an {@link
 * IllegalStateException}.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]


OneOfDiscriminatorWithoutMapping=[
/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * Unlike {@link ComposedOneofDto#fold(Function, Function)}, this method accepts
 * as last parameter a {@link Supplier} which gets called in case this instance is
 * not valid against exactly one of the defined schemas and its value is returned.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if ("User".equals(requiredStringVal) && isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if ("NecessityAndNullability".equals(requiredStringVal) && isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against exactly one of the schemas. If it is
 * either valid against no schema or multiple schemas, it will throw an {@link
 * IllegalStateException}.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]


OneOfNoDiscriminator=[
/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * Unlike {@link ComposedOneofDto#fold(Function, Function)}, this method accepts
 * as last parameter a {@link Supplier} which gets called in case this instance is
 * not valid against exactly one of the defined schemas and its value is returned.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if (isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if (isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against exactly one of the schemas. If it is
 * either valid against no schema or multiple schemas, it will throw an {@link
 * IllegalStateException}.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]