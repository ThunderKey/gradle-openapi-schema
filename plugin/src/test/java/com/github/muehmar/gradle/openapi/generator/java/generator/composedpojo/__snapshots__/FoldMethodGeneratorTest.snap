AnyOf=[

public <T> List<T> fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  final List<T> result = new ArrayList<>();
  if (isValidAgainstUser()) {
    result.add(onUserDto.apply(asUserDto()));
  }
  if (isValidAgainstNecessityAndNullability()) {
    result.add(onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto()));
  }
  return result;
}
]


OneOfDiscriminatorWithMapping=[
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if ("UserValue".equals(requiredStringVal) && isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if ("NNVariantsValue".equals(requiredStringVal) && isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against exactly one of the schemas. If it is
 * either valid against no schema or multiple schemas, it will throw an {@link
 * IllegalStateException}.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]


OneOfDiscriminatorWithoutMapping=[
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if ("User".equals(requiredStringVal) && isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if ("NecessityAndNullability".equals(requiredStringVal) && isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against exactly one of the schemas. If it is
 * either valid against no schema or multiple schemas, it will throw an {@link
 * IllegalStateException}.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]


OneOfNoDiscriminator=[
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto, Supplier<T> onInvalid) {
  if (isValidAgainstUser()) {
    return onUserDto.apply(asUserDto());
  }
  else if (isValidAgainstNecessityAndNullability()) {
    return onNecessityAndNullabilityDto.apply(asNecessityAndNullabilityDto());
  }
  else {
    return onInvalid.get();
  }
}

/**
 * Folds this instance using the given mapping functions for the DTO's. If this
 * instance is valid against exactly one of the specified schemas, its
 * corresponding mapping function gets executed with the DTO as input and its
 * result is returned.<br><br>
 * 
 * I.e. if the JSON was valid against the schema 'User', the mapping method {@code
 * onUserDto} gets executed with the {@link UserDto} as argument.<br><br>
 * 
 * This method assumes this instance is either manually or automatically
 * validated, i.e. the JSON is valid against exactly one of the schemas. If it is
 * either valid against no schema or multiple schemas, it will throw an {@link
 * IllegalStateException}.
 */
public <T> T fold(Function<UserDto, T> onUserDto, Function<NecessityAndNullabilityDto, T> onNecessityAndNullabilityDto) {
  return fold(
    onUserDto,
    onNecessityAndNullabilityDto,
    () -> {throw new IllegalStateException("Unable to fold ComposedOneofDto: Not valid against one of the schemas [UserDto, NecessityAndNullabilityDto].");}
  );
}
]