package com.github.muehmar.gradle.openapi.generator.java.generator.shared.validation.email;

import com.github.muehmar.gradle.openapi.generator.java.ref.OpenApiUtilRefs;
import io.github.muehmar.codegenerator.Generator;

public class EmailValidatorGenerator {
  private EmailValidatorGenerator() {}

  public static <A, B> Generator<A, B> emailValidatorGenerator() {
    return Generator.<A, B>emptyGen()
        .append(w -> w.println("package %s;", OpenApiUtilRefs.OPENAPI_UTIL_PACKAGE))
        .appendSingleBlankLine()
        .append(
            w ->
                w.println(
                    "%s",
                    "import static java.util.regex.Pattern.CASE_INSENSITIVE;\n"
                        + "\n"
                        + "import java.net.IDN;\n"
                        + "import java.util.regex.Matcher;\n"
                        + "import java.util.regex.Pattern;\n"
                        + "\n"
                        + "/**\n"
                        + " * This validator is extracted from the hibernate validator v6.2.5 and consolidated into a single\n"
                        + " * class.\n"
                        + " */\n"
                        + "public class EmailValidator {\n"
                        + "  // This part is from the class AbstractEmailValidator\n"
                        + "  private static final int MAX_LOCAL_PART_LENGTH = 64;\n"
                        + "\n"
                        + "  private static final String LOCAL_PART_ATOM = \"[a-z0-9!#$%&'*+/=?^_`{|}~\\u0080-\\uFFFF-]\";\n"
                        + "  private static final String LOCAL_PART_INSIDE_QUOTES_ATOM =\n"
                        + "      \"(?:[a-z0-9!#$%&'*.(),<>\\\\[\\\\]:;  @+/=?^_`{|}~\\u0080-\\uFFFF-]|\\\\\\\\\\\\\\\\|\\\\\\\\\\\\\\\")\";\n"
                        + "  /** Regular expression for the local part of an email address (everything before '@') */\n"
                        + "  private static final Pattern LOCAL_PART_PATTERN =\n"
                        + "      Pattern.compile(\n"
                        + "          \"(?:\"\n"
                        + "              + LOCAL_PART_ATOM\n"
                        + "              + \"+|\\\"\"\n"
                        + "              + LOCAL_PART_INSIDE_QUOTES_ATOM\n"
                        + "              + \"+\\\")\"\n"
                        + "              + \"(?:\\\\.\"\n"
                        + "              + \"(?:\"\n"
                        + "              + LOCAL_PART_ATOM\n"
                        + "              + \"+|\\\"\"\n"
                        + "              + LOCAL_PART_INSIDE_QUOTES_ATOM\n"
                        + "              + \"+\\\")\"\n"
                        + "              + \")*\",\n"
                        + "          CASE_INSENSITIVE);\n"
                        + "\n"
                        + "  public static boolean isValid(CharSequence value) {\n"
                        + "    if (value == null || value.length() == 0) {\n"
                        + "      return true;\n"
                        + "    }\n"
                        + "\n"
                        + "    // cannot split email string at @ as it can be a part of quoted local part of email.\n"
                        + "    // so we need to split at a position of last @ present in the string:\n"
                        + "    String stringValue = value.toString();\n"
                        + "    int splitPosition = stringValue.lastIndexOf('@');\n"
                        + "\n"
                        + "    // need to check if\n"
                        + "    if (splitPosition < 0) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "\n"
                        + "    String localPart = stringValue.substring(0, splitPosition);\n"
                        + "    String domainPart = stringValue.substring(splitPosition + 1);\n"
                        + "\n"
                        + "    if (!isValidEmailLocalPart(localPart)) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "\n"
                        + "    return isValidEmailDomainAddress(domainPart);\n"
                        + "  }\n"
                        + "\n"
                        + "  private static boolean isValidEmailLocalPart(String localPart) {\n"
                        + "    if (localPart.length() > MAX_LOCAL_PART_LENGTH) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "    Matcher matcher = LOCAL_PART_PATTERN.matcher(localPart);\n"
                        + "    return matcher.matches();\n"
                        + "  }\n"
                        + "\n"
                        + "  // This part is from the class DomainNameUtil\n"
                        + "  /**\n"
                        + "   * This is the maximum length of a domain name. But be aware that each label (parts separated by a\n"
                        + "   * dot) of the domain name must be at most 63 characters long. This is verified by {@link\n"
                        + "   * IDN#toASCII(String)}.\n"
                        + "   */\n"
                        + "  private static final int MAX_DOMAIN_PART_LENGTH = 255;\n"
                        + "\n"
                        + "  private static final String DOMAIN_CHARS_WITHOUT_DASH = \"[a-z\\u0080-\\uFFFF0-9!#$%&'*+/=?^_`{|}~]\";\n"
                        + "  private static final String DOMAIN_LABEL =\n"
                        + "      \"(?:\" + DOMAIN_CHARS_WITHOUT_DASH + \"-*)*\" + DOMAIN_CHARS_WITHOUT_DASH + \"+\";\n"
                        + "  private static final String DOMAIN = DOMAIN_LABEL + \"+(?:\\\\.\" + DOMAIN_LABEL + \"+)*\";\n"
                        + "\n"
                        + "  private static final String IP_DOMAIN = \"[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\";\n"
                        + "  // IP v6 regex taken from\n"
                        + "  // http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n"
                        + "  private static final String IP_V6_DOMAIN =\n"
                        + "      \"(?:(?:[0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,7}:|(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|(?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}|(?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}|(?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}|(?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:(?:(?::[0-9a-fA-F]{1,4}){1,6})|:(?:(?::[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(?::[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(?:ffff(:0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|(?:[0-9a-fA-F]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\";\n"
                        + "\n"
                        + "  /** Regular expression for the domain part of an email address (everything after '@') */\n"
                        + "  private static final Pattern EMAIL_DOMAIN_PATTERN =\n"
                        + "      Pattern.compile(\n"
                        + "          DOMAIN + \"|\\\\[\" + IP_DOMAIN + \"\\\\]|\" + \"\\\\[IPv6:\" + IP_V6_DOMAIN + \"\\\\]\",\n"
                        + "          CASE_INSENSITIVE);\n"
                        + "\n"
                        + "  /**\n"
                        + "   * Checks the validity of the domain name used in an email. To be valid it should be either a\n"
                        + "   * valid host name, or an IP address wrapped in [].\n"
                        + "   *\n"
                        + "   * @param domain domain to check for validity\n"
                        + "   * @return {@code true} if the provided string is a valid domain, {@code false} otherwise\n"
                        + "   */\n"
                        + "  private static boolean isValidEmailDomainAddress(String domain) {\n"
                        + "    return isValidDomainAddress(domain, EMAIL_DOMAIN_PATTERN);\n"
                        + "  }\n"
                        + "\n"
                        + "  private static boolean isValidDomainAddress(String domain, Pattern pattern) {\n"
                        + "    // if we have a trailing dot the domain part we have an invalid email address.\n"
                        + "    // the regular expression match would take care of this, but IDN.toASCII drops the trailing '.'\n"
                        + "    if (domain.endsWith(\".\")) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "\n"
                        + "    String asciiString;\n"
                        + "    try {\n"
                        + "      asciiString = IDN.toASCII(domain);\n"
                        + "    } catch (IllegalArgumentException e) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "\n"
                        + "    if (asciiString.length() > MAX_DOMAIN_PART_LENGTH) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "\n"
                        + "    Matcher matcher = pattern.matcher(domain);\n"
                        + "    if (!matcher.matches()) {\n"
                        + "      return false;\n"
                        + "    }\n"
                        + "\n"
                        + "    return true;\n"
                        + "  }\n"
                        + "}\n"));
  }
}
